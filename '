#pragma once
#include "mastermind_definitions.h"
#include <stdlib.h>
#include <stdbool.h>

void make_random_guess(int curGuessI,
	char guesses[NUM_GUESSES][CODE_LENGTH])
{
	unsigned short randomNumber = rand();
	int choices = NUM_WITH_BLANK;
	for (int i = 0; i < CODE_LENGTH; i++)
	{
		guesses[curGuessI][i] = randomNumber % choices;
		randomNumber /= choices;
	}
}

// converts a code to an index in the space of possible codes
int code_to_index(char code[CODE_LENGTH]) {
	int index = 0;
	int exponent = 1;
	for (int i = 0; i < CODE_LENGTH; i++) {
		index += code[i] * exponent;
		exponent *= NUM_WITH_BLANK;
	}
	return index;
}

// reverse
void index_to_code(int index, char code[CODE_LENGTH]) {
	for (int i = 0; i < CODE_LENGTH; i++) {
		code[i] = index % NUM_WITH_BLANK;
		index /= NUM_WITH_BLANK;
	}
}

static int colorPossibility[NUM_WITH_BLANK];
// -1 - this color is definitely not present
// 0 - this color is possibly, but not definitely present
// 1 to 4 - how many times this color is definitely present

#define COLOR_IS_IMPOSSIBLE -1
#define COLOR_IS_POSSIBLE 0

static int definiteCodePositions[CODE_LENGTH];
// -1 - this code position is unknown
// 0 to 6 - code position is definitely this color

static bool codePossibility[CODE_SPACE];

static int prevGuessI;
// used for continuing analysis where it last left off

static char breakersGuess[CODE_LENGTH];

void reset_code_breaker() {
	for (int i = 0; i < NUM_WITH_BLANK; i++) {
		colorPossibility[i] = COLOR_IS_POSSIBLE;
	}
	for (int i = 0; i < CODE_LENGTH; i++) {
		definiteCodePositions[i] = -1;
	}
	for (int i = 0; i < CODE_SPACE; i++) {
		codePossibility[i] = true;
	}
	for (int i = 0; i < CODE_LENGTH; i++) {
		breakersGuess[CODE_LENGTH] = -1;
	}
	prevGuessI = -1;
}

void make_smart_guess(int curGuessI,
	char guesses[NUM_GUESSES][CODE_LENGTH],
	char keys[NUM_GUESSES][CODE_LENGTH])
{
	// extract information from previous guesses if any

	for (int i = prevGuessI; i < curGuessI; i++) {
		int numCorrectColors = 0;
		int numCorrectPos = 0;
		int cntColors[NUM_WITH_BLANK] = {0};
		int numUniqueColors = 0;
		int numDefiniteColors = 0;
		int numUniqueDefiniteColors = 0;
	
		for (int j = 0; j < CODE_LENGTH; j++) {
			if (keys[i][j] == KEY_RED) {
				numCorrectPos++;
				numCorrectColors++;
			}
			else if (keys[i][j] == KEY_WHITE) {
				numCorrectColors++;
			}

			if (cntColors[guesses[i][j]]++ == 0) {
				numUniqueColors++;
			}
			
			if (colorPossibility[guesses[i][j]] > 0) {
				numDefiniteColors++;
				if (cntColors[guesses[i][j]] == 1) {
					numUniqueDefiniteColors++;
				}
			}
		}
		int numNewCorrectColors = numCorrectColors - numDefiniteColors;
		int numNewUniqueColors = numUniqueColors - numUniqueDefiniteColors;
		
		if (numNewCorrectColors == 0) {
			for (int j = 0; j < CODE_LENGTH; j++) {
				if (colorPossibility[guesses[i][j]] == 0) {
					colorPossibility[guesses[i][j]] = COLOR_IS_IMPOSSIBLE;
				}
			}
		}
		else if (numNewUniqueColors == 1) {
			for (int j = 0; j < CODE_LENGTH; j++) {
				if (colorPossibility[guesses[i][j]] == 0) {
					colorPossibility[guesses[i][j]] = numNewCorrectColors;
				}
			}
		}
	}

	printf("Color possibility: ");
	for (int i = 0; i < NUM_WITH_BLANK; i++) {
		printf("%d ", colorPossibility[i]);
	}
	printf("\n");

	prevGuessI = curGuessI;
	int definiteColorCnt = 0;
	for (int i = 0; i < NUM_WITH_BLANK; i++) {
		for (int j = 0; j < colorPossibility[i]; j++) {
			guesses[curGuessI][definiteColorCnt++] = i;
		}
	}
	
	if (definiteColorCnt < CODE_LENGTH) {
		for (int i = 0; i < NUM_WITH_BLANK; i++) {
			if (colorPossibility[i] == 0) {
				for (int j = definiteColorCnt; j < CODE_LENGTH; j++) {
					guesses[curGuessI][j] = i;
				}
				return;
			}
		}
	}
	
	for (int i = 0; i < curGuessI; i++) {
		
	}
}
